script:
  - id: activate_scene
    parameters:
      scene_id: string
    then:
      - homeassistant.service:
          service: scene.turn_on
          data:
            entity_id: !lambda 'return scene_id;'

  - id: update_weather_ui
    then:
      - lvgl.label.update:
          id: weather_temp_label
          text: !lambda 'return to_string((int)id(forecast_home_temperature).state) + "Â°C";'
      - lvgl.label.update:
          id: weather_hum_label
          text: !lambda 'return to_string((int)id(forecast_home_humidity).state) + "%";'
      - lvgl.label.update:
          id: weather_pres_label
          text: !lambda 'return to_string((int)id(forecast_home_pressure).state) + "hPa";'
      - lambda: |-
          if (id(forecast_home_rain_60min).state) {
            lv_obj_clear_flag(id(weather_rain_icon), LV_OBJ_FLAG_HIDDEN);
          } else {
            lv_obj_add_flag(id(weather_rain_icon), LV_OBJ_FLAG_HIDDEN);
          }
      - lvgl.label.update:
          id: weather_icon_label
          text: !lambda |-
            std::string state = id(forecast_home_state).state;
            if (state == "sunny") return "\U000F0599"; // sunny
            if (state == "clear-night") return "\U000F0594"; // night
            if (state == "cloudy") return "\U000F0590"; // cloudy
            if (state == "partlycloudy") return "\U000F0595"; // partly-cloudy
            if (state == "rainy") return "\U000F0597"; // rainy
            if (state == "snowy") return "\U000F0598"; // snowy
            if (state == "lightning") return "\U000F0593"; // lightning
            if (state == "fog") return "\U000F0591"; // fog
            return "\U000F015F"; // default cloud

  - id: update_graph_ui
    then:
      - lambda: |-
          // Always collect data, but only update UI if backlight is on
          if (id(backlight).remote_values.is_on()) {
            float min_v = 1000000, max_v = -1000000;
            if (id(chart_values).empty()) {
              min_v = 0; max_v = 100;
            } else {
              for (float v : id(chart_values)) {
                if (v < min_v) min_v = v;
                if (v > max_v) max_v = v;
              }
              // Add some padding
              float range = max_v - min_v;
              if (range < 1) range = 1;
              min_v -= range * 0.1;
              max_v += range * 0.1;
            }
            update_lvgl_chart(id(chart_values), min_v, max_v);
          }
      - if:
          condition:
            lambda: 'return id(backlight).remote_values.is_on();'
          then:
            - lvgl.label.update:
                id: home_power_graph_value_label
                text: !lambda |-
                  if (id(chart_values).empty()) return std::string("-- W");
                  char buf[32];
                  sprintf(buf, "%.1f W", id(chart_values).back());
                  return std::string(buf);

  - id: init_power_graph
    then:
      - lambda: |-
          // We use the ID from overview.yaml: home_power_graph_chart_container
          auto container = id(home_power_graph_chart_container);
          if (container != nullptr) {
            lv_obj_update_layout(container);
            int w = lv_obj_get_width(container)-10; // padding
            int h = lv_obj_get_height(container)-10;
            init_lvgl_chart(container, w, h, 0, 0, 0xEF8513);
            id(update_graph_ui).execute();
          }

  # UI Bridge Scripts (Hardware to UI)
  - id: ui_home
    then:
      - lvgl.resume:
      - light.turn_on: backlight
      - script.execute: update_graph_ui
      - lambda: |-
          if (id(main_tabs) != nullptr) {
            lv_tabview_set_act(id(main_tabs), 0, LV_ANIM_ON);
          }

  - id: ui_next_tab
    then:
      - lvgl.resume:
      - light.turn_on: backlight
      - script.execute: update_graph_ui
      - lambda: |-
          if (id(main_tabs) != nullptr) {
            uint16_t count = lv_obj_get_child_cnt(lv_tabview_get_content(id(main_tabs)));
            uint16_t current = lv_tabview_get_tab_act(id(main_tabs));
            lv_tabview_set_act(id(main_tabs), (current + 1) % count, LV_ANIM_ON);
          }

  - id: ui_prev_tab
    then:
      - lvgl.resume:
      - light.turn_on: backlight
      - lambda: |-
          if (id(main_tabs) != nullptr) {
            uint16_t count = lv_obj_get_child_cnt(lv_tabview_get_content(id(main_tabs)));
            uint16_t current = lv_tabview_get_tab_act(id(main_tabs));
            lv_tabview_set_act(id(main_tabs), (current + count - 1) % count, LV_ANIM_ON);
          }

interval:
  - interval: 1s
    then:
      - lvgl.label.update:
          id: clock_label
          text: !lambda 'return id(home_time).now().strftime("%H:%M");'
      - lvgl.label.update:
          id: clock_date_label
          text: !lambda 'return id(home_time).now().strftime("%a, %b %d");'
